<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AppFlowy Database Architecture - Technical Documentation</title>
    <style>
        :root {
            --primary-color: #6366f1;
            --secondary-color: #f1f5f9;
            --text-color: #1e293b;
            --border-color: #e2e8f0;
            --code-bg: #f8fafc;
            --accent-color: #0ea5e9;
        }
        
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            line-height: 1.6;
            color: var(--text-color);
            background: #fafbfc;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 20px;
        }
        
        header {
            background: white;
            border-bottom: 2px solid var(--border-color);
            padding: 20px 0;
            position: sticky;
            top: 0;
            z-index: 100;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }
        
        h1 {
            color: var(--primary-color);
            font-size: 2.5rem;
            font-weight: 700;
            margin-bottom: 10px;
        }
        
        .subtitle {
            color: #64748b;
            font-size: 1.1rem;
            font-weight: 400;
        }
        
        nav {
            background: var(--secondary-color);
            padding: 15px 0;
            border-bottom: 1px solid var(--border-color);
        }
        
        .nav-links {
            display: flex;
            gap: 30px;
            flex-wrap: wrap;
        }
        
        .nav-links a {
            color: var(--text-color);
            text-decoration: none;
            font-weight: 500;
            padding: 8px 16px;
            border-radius: 6px;
            transition: background 0.2s;
        }
        
        .nav-links a:hover, .nav-links a.active {
            background: var(--primary-color);
            color: white;
        }
        
        main {
            padding: 40px 0;
        }
        
        .section {
            background: white;
            border-radius: 12px;
            padding: 30px;
            margin-bottom: 30px;
            border: 1px solid var(--border-color);
            box-shadow: 0 2px 8px rgba(0,0,0,0.04);
        }
        
        h2 {
            color: var(--primary-color);
            font-size: 2rem;
            margin-bottom: 20px;
            border-bottom: 3px solid var(--primary-color);
            padding-bottom: 10px;
        }
        
        h3 {
            color: var(--accent-color);
            font-size: 1.4rem;
            margin: 25px 0 15px 0;
        }
        
        h4 {
            color: var(--text-color);
            font-size: 1.1rem;
            margin: 20px 0 10px 0;
            font-weight: 600;
        }
        
        p, li {
            margin-bottom: 12px;
        }
        
        ul, ol {
            margin-left: 25px;
        }
        
        li {
            margin-bottom: 8px;
        }
        
        .code-block {
            background: var(--code-bg);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
            overflow-x: auto;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 0.9rem;
            line-height: 1.4;
        }
        
        .inline-code {
            background: var(--code-bg);
            padding: 3px 6px;
            border-radius: 4px;
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 0.9em;
            border: 1px solid #e5e7eb;
        }
        
        .architecture-diagram {
            background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
            border: 2px solid var(--border-color);
            border-radius: 12px;
            padding: 30px;
            margin: 25px 0;
            text-align: center;
        }
        
        .layer {
            background: white;
            border: 2px solid var(--primary-color);
            border-radius: 8px;
            padding: 15px;
            margin: 10px 0;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        
        .layer h4 {
            color: var(--primary-color);
            margin-bottom: 10px;
        }
        
        .component-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        
        .component-card {
            background: linear-gradient(135deg, #fafbfc 0%, #f1f5f9 100%);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 20px;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        
        .component-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 16px rgba(0,0,0,0.1);
        }
        
        .component-card h4 {
            color: var(--accent-color);
            margin-bottom: 12px;
        }
        
        .highlight {
            background: linear-gradient(90deg, #fef3c7, #fbbf24);
            padding: 2px 8px;
            border-radius: 4px;
            font-weight: 600;
        }
        
        .warning {
            background: #fef2f2;
            border: 1px solid #fecaca;
            border-left: 4px solid #ef4444;
            border-radius: 6px;
            padding: 15px;
            margin: 20px 0;
        }
        
        .info {
            background: #eff6ff;
            border: 1px solid #bfdbfe;
            border-left: 4px solid #3b82f6;
            border-radius: 6px;
            padding: 15px;
            margin: 20px 0;
        }
        
        .data-flow {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 20px;
            margin: 20px 0;
            flex-wrap: wrap;
        }
        
        .flow-step {
            background: white;
            border: 2px solid var(--accent-color);
            border-radius: 8px;
            padding: 15px 20px;
            text-align: center;
            min-width: 150px;
        }
        
        .flow-arrow {
            font-size: 1.5rem;
            color: var(--accent-color);
            font-weight: bold;
        }
        
        footer {
            background: var(--text-color);
            color: white;
            text-align: center;
            padding: 30px 0;
            margin-top: 60px;
        }
        
        @media (max-width: 768px) {
            .container { padding: 0 15px; }
            h1 { font-size: 2rem; }
            h2 { font-size: 1.6rem; }
            .component-grid { grid-template-columns: 1fr; }
            .nav-links { flex-direction: column; gap: 10px; }
            .data-flow { flex-direction: column; }
            .flow-arrow { transform: rotate(90deg); }
        }
    </style>
</head>
<body>
    <header>
        <div class="container">
            <h1>AppFlowy Database Architecture</h1>
            <p class="subtitle">Comprehensive Technical Documentation for Web Implementation</p>
        </div>
    </header>

    <nav>
        <div class="container">
            <div class="nav-links">
                <a href="#overview" class="active">Architecture Overview</a>
                <a href="#frontend">Frontend Components</a>
                <a href="#backend">Backend Services</a>
                <a href="#data-flow">Data Flow</a>
                <a href="#storage">Storage & Sync</a>
                <a href="#implementation">Implementation Guidelines</a>
            </div>
        </div>
    </nav>

    <main>
        <div class="container">
            <section id="overview" class="section">
                <h2>üèóÔ∏è Architecture Overview</h2>
                
                <div class="info">
                    <strong>Key Insight:</strong> AppFlowy's database architecture is designed around collaborative editing with a clear separation between frontend Flutter components and backend Rust services, connected through protobuf-defined interfaces.
                </div>

                <div class="architecture-diagram">
                    <div class="layer">
                        <h4>Frontend Layer (Flutter/Dart)</h4>
                        <p>UI components, state management (BLoC), and user interaction handling</p>
                    </div>
                    <div class="layer">
                        <h4>Communication Layer (Protobuf + FFI)</h4>
                        <p>Event-driven messaging between frontend and backend</p>
                    </div>
                    <div class="layer">
                        <h4>Backend Layer (Rust)</h4>
                        <p>Core business logic, collaborative editing, and data persistence</p>
                    </div>
                    <div class="layer">
                        <h4>Storage Layer</h4>
                        <p>SQLite for local storage + Cloud sync for collaboration</p>
                    </div>
                </div>

                <h3>üéØ Core Design Principles</h3>
                <ul>
                    <li><strong>Event-Driven Architecture:</strong> All operations trigger events that propagate through the system</li>
                    <li><strong>Multi-Layer Caching:</strong> Efficient data management at cell, row, and view levels</li>
                    <li><strong>Collaborative Real-time Sync:</strong> Operational transforms for concurrent editing</li>
                    <li><strong>Type-Safe Communication:</strong> Protobuf schemas ensure data integrity across layers</li>
                    <li><strong>Modular Field System:</strong> Extensible field types with custom editors and renderers</li>
                </ul>
            </section>

            <section id="frontend" class="section">
                <h2>üé® Frontend Architecture (Flutter/Dart)</h2>

                <h3>Core Controllers</h3>
                <div class="component-grid">
                    <div class="component-card">
                        <h4>DatabaseController</h4>
                        <p>Central orchestrator managing database state, field operations, and row operations. Acts as the main entry point for all database interactions.</p>
                        <div class="code-block">DatabaseController(
  view: view,
  fieldsController: fieldsController,
  rowController: rowController,
)</div>
                    </div>

                    <div class="component-card">
                        <h4>RowCache</h4>
                        <p>Manages in-memory row data with change notifications and cell caching. Provides efficient row-level operations and data synchronization.</p>
                        <div class="code-block">RowCache(
  viewId: viewId,
  fieldController: fieldController,
  delegate: RowCacheDelegateImpl(),
)</div>
                    </div>

                    <div class="component-card">
                        <h4>FieldController</h4>
                        <p>Handles field-specific operations and metadata management. Controls field types, properties, and validation rules.</p>
                        <div class="code-block">FieldController(
  viewId: viewId,
  fieldBackendSvc: fieldBackendSvc,
)</div>
                    </div>

                    <div class="component-card">
                        <h4>CellCache</h4>
                        <p>Provides efficient cell-level caching and data management. Optimizes individual cell operations and reduces backend calls.</p>
                        <div class="code-block">CellMemCache(
  cellLoader: CellLoader(
    reloadOnFieldChanged: true,
  ),
)</div>
                    </div>
                </div>

                <h3>State Management Pattern (BLoC)</h3>
                <div class="code-block">// Typical database BLoC implementation
class DatabaseBloc extends Bloc&lt;DatabaseEvent, DatabaseState&gt; {
  final DatabaseController databaseController;
  
  DatabaseBloc({required this.databaseController}) 
      : super(const DatabaseState.initial()) {
    _startListening();
  }

  void _startListening() {
    databaseController.addListener(() {
      add(DatabaseEvent.didReceiveDatabaseUpdate());
    });
  }
}

// Event-driven updates
abstract class DatabaseEvent {
  const DatabaseEvent();
  const factory DatabaseEvent.initial() = _Initial;
  const factory DatabaseEvent.didReceiveDatabaseUpdate() = _DidReceiveDatabaseUpdate;
  const factory DatabaseEvent.didUpdateFields(List&lt;FieldInfo&gt; fields) = _DidUpdateFields;
}</div>

                <div class="warning">
                    <strong>Important:</strong> The frontend never directly manipulates data. All operations go through the backend via event messaging, ensuring data consistency and enabling real-time collaboration.
                </div>
            </section>

            <section id="backend" class="section">
                <h2>‚öôÔ∏è Backend Architecture (Rust)</h2>

                <h3>Core Services</h3>
                <div class="component-grid">
                    <div class="component-card">
                        <h4>DatabaseEditor</h4>
                        <p>Core database management with collaborative editing support. Handles database-level operations and coordinates with view editors.</p>
                        <div class="code-block">impl DatabaseEditor {
  pub async fn create_row(&amp;self, params: CreateRowParams) 
      -> FlowyResult&lt;RowDetail&gt; {
    // Row creation logic
  }
  
  pub async fn update_cell(&amp;self, changeset: CellChangeset) 
      -> FlowyResult&lt;()&gt; {
    // Cell update with collaboration
  }
}</div>
                    </div>

                    <div class="component-card">
                        <h4>DatabaseViewEditor</h4>
                        <p>View-specific operations handling grid, board, and calendar layouts. Manages view-specific state and filtering.</p>
                        <div class="code-block">impl DatabaseViewEditor {
  pub async fn move_group_row(&amp;self, params: MoveGroupRowParams) 
      -> FlowyResult&lt;()&gt; {
    // Row movement between groups
  }
  
  pub async fn create_group(&amp;self, params: InsertGroupParams) 
      -> FlowyResult&lt;()&gt; {
    // Group creation for board view
  }
}</div>
                    </div>

                    <div class="component-card">
                        <h4>GroupController</h4>
                        <p>Manages grouping logic for board views. Handles group creation, row assignment, and group-specific operations.</p>
                        <div class="code-block">pub struct GroupController {
    pub field_id: String,
    pub groups: Vec&lt;Group&gt;,
    pub configuration: GroupConfiguration,
}

impl GroupController {
  pub async fn move_row(&amp;mut self, context: MoveGroupRowContext) 
      -> FlowyResult&lt;()&gt; {
    // Handle row movement logic
  }
}</div>
                    </div>

                    <div class="component-card">
                        <h4>CellCache (Backend)</h4>
                        <p>Backend cell-level data caching and validation. Ensures data integrity and provides efficient cell operations.</p>
                        <div class="code-block">impl CellCache {
  pub fn get_cell(&amp;self, cell_id: &amp;CellId) 
      -> Option&lt;Cell&gt; {
    // Retrieve cached cell data
  }
  
  pub async fn set_cell(&amp;mut self, cell_id: CellId, cell: Cell) 
      -> FlowyResult&lt;()&gt; {
    // Update cell with validation
  }
}</div>
                    </div>
                </div>

                <h3>Collaborative Database (Collab)</h3>
                <div class="info">
                    <strong>Collaboration Engine:</strong> AppFlowy uses a sophisticated operational transform system built on top of Yjs/Yrs for real-time collaborative editing. This ensures consistency across multiple users editing the same database simultaneously.
                </div>

                <div class="code-block">// Collaborative database structure
pub struct Database {
    pub collab: Arc&lt;MutexCollab&gt;,
    pub body: DatabaseBody,
    pub lock: Arc&lt;RwLock&lt;()&gt;&gt;,
}

// Operational transforms for collaborative editing
impl Database {
    pub fn apply_change(&amp;self, change: DatabaseChange) -&gt; FlowyResult&lt;()&gt; {
        let txn = self.collab.lock().transact_mut();
        // Apply operational transform
        self.body.apply_change_with_txn(&amp;mut txn, change)?;
        Ok(())
    }
}</div>
            </section>

            <section id="data-flow" class="section">
                <h2>üîÑ Data Flow Patterns</h2>

                <h3>Frontend to Backend Communication</h3>
                <div class="data-flow">
                    <div class="flow-step">
                        <strong>User Action</strong><br>
                        UI Component
                    </div>
                    <div class="flow-arrow">‚Üí</div>
                    <div class="flow-step">
                        <strong>BLoC Event</strong><br>
                        State Management
                    </div>
                    <div class="flow-arrow">‚Üí</div>
                    <div class="flow-step">
                        <strong>FFI Call</strong><br>
                        Protobuf Message
                    </div>
                    <div class="flow-arrow">‚Üí</div>
                    <div class="flow-step">
                        <strong>Backend Service</strong><br>
                        Rust Implementation
                    </div>
                </div>

                <h3>Backend to Frontend Notifications</h3>
                <div class="data-flow">
                    <div class="flow-step">
                        <strong>Data Change</strong><br>
                        Backend Service
                    </div>
                    <div class="flow-arrow">‚Üí</div>
                    <div class="flow-step">
                        <strong>Notification</strong><br>
                        Broadcast Channel
                    </div>
                    <div class="flow-arrow">‚Üí</div>
                    <div class="flow-step">
                        <strong>Listener</strong><br>
                        Frontend Controller
                    </div>
                    <div class="flow-arrow">‚Üí</div>
                    <div class="flow-step">
                        <strong>UI Update</strong><br>
                        BLoC State Emit
                    </div>
                </div>

                <h3>Typical Operation Flow</h3>
                <div class="code-block">// Example: Creating a new row
1. User clicks "Add Card" in board view
   ‚îî‚îÄ‚Üí BoardColumnFooter widget triggers action

2. BLoC receives event
   ‚îî‚îÄ‚Üí BoardBloc.add(BoardEvent.createRow(groupId, position, name))

3. Controller processes request
   ‚îî‚îÄ‚Üí databaseController.createRow(CreateRowParams)

4. FFI call to backend
   ‚îî‚îÄ‚Üí DatabaseEventCreateRow protobuf message

5. Rust backend processes
   ‚îî‚îÄ‚Üí DatabaseEditor.create_row() implementation

6. Database update with collaboration
   ‚îî‚îÄ‚Üí Operational transform applied to collaborative document

7. Notification sent back
   ‚îî‚îÄ‚Üí DatabaseNotification.DidUpdateViewRowsVisibility

8. Frontend listeners update UI
   ‚îî‚îÄ‚Üí BLoC emits new state, UI rebuilds automatically</div>
            </section>

            <section id="storage" class="section">
                <h2>üíæ Storage & Synchronization</h2>

                <h3>Local Storage (SQLite)</h3>
                <div class="component-grid">
                    <div class="component-card">
                        <h4>Database Tables</h4>
                        <ul>
                            <li><span class="inline-code">collab_snapshot</span> - Document snapshots</li>
                            <li><span class="inline-code">collab_state</span> - Collaboration state</li>
                            <li><span class="inline-code">user_data</span> - User-specific data</li>
                            <li><span class="inline-code">workspace</span> - Workspace information</li>
                        </ul>
                    </div>

                    <div class="component-card">
                        <h4>Caching Strategy</h4>
                        <ul>
                            <li><strong>View Cache:</strong> Complete view data</li>
                            <li><strong>Row Cache:</strong> Individual row data</li>
                            <li><strong>Cell Cache:</strong> Granular cell data</li>
                            <li><strong>Field Cache:</strong> Field metadata</li>
                        </ul>
                    </div>
                </div>

                <h3>Cloud Synchronization</h3>
                <div class="info">
                    <strong>Sync Architecture:</strong> AppFlowy uses a sophisticated synchronization system that handles offline-first scenarios with conflict resolution through operational transforms.
                </div>

                <div class="code-block">// Synchronization flow
pub struct DatabaseCloudService {
    pub cloud_service: Arc&lt;dyn DatabaseCloudService&gt;,
}

impl DatabaseCloudService {
    // Push local changes to cloud
    pub async fn push_updates(&amp;self, workspace_id: &amp;str, updates: Vec&lt;DatabaseUpdate&gt;) 
        -> FlowyResult&lt;()&gt; {
        // Upload operational transforms
    }
    
    // Pull remote changes from cloud  
    pub async fn pull_updates(&amp;self, workspace_id: &amp;str) 
        -> FlowyResult&lt;Vec&lt;DatabaseUpdate&gt;&gt; {
        // Download and apply remote changes
    }
}</div>

                <h3>Conflict Resolution</h3>
                <ul>
                    <li><strong>Operational Transforms:</strong> Changes are represented as operations that can be applied in any order</li>
                    <li><strong>Vector Clocks:</strong> Track causality between changes from different users</li>
                    <li><strong>Last-Writer-Wins:</strong> For simple conflicts, timestamp-based resolution</li>
                    <li><strong>Merge Strategies:</strong> Field-specific merge logic for complex data types</li>
                </ul>
            </section>

            <section id="implementation" class="section">
                <h2>üöÄ Web Implementation Guidelines</h2>

                <h3>Architecture Translation</h3>
                <div class="component-grid">
                    <div class="component-card">
                        <h4>Frontend (React/Vue + TypeScript)</h4>
                        <ul>
                            <li>Replace BLoC with Context/Redux/Zustand</li>
                            <li>Use React Query/SWR for data fetching</li>
                            <li>Implement similar controller patterns</li>
                            <li>Maintain multi-layer caching</li>
                        </ul>
                    </div>

                    <div class="component-card">
                        <h4>Backend Integration</h4>
                        <ul>
                            <li>Compile Rust backend to WASM</li>
                            <li>Maintain protobuf communication</li>
                            <li>Use Web Workers for heavy operations</li>
                            <li>Implement IndexedDB for local storage</li>
                        </ul>
                    </div>
                </div>

                <h3>Key Patterns to Preserve</h3>
                <div class="highlight">Event-Driven Architecture</div>
                <p>Maintain the event-driven pattern where UI actions trigger events that propagate through the system.</p>

                <div class="highlight">Multi-Layer Caching</div>  
                <p>Implement view, row, and cell-level caching to minimize backend calls and improve performance.</p>

                <div class="highlight">Collaborative Synchronization</div>
                <p>Preserve the operational transform system for real-time collaboration features.</p>

                <div class="highlight">Type-Safe Communication</div>
                <p>Use TypeScript and maintain protobuf schemas for type safety across layers.</p>

                <h3>Web-Specific Considerations</h3>
                <ul>
                    <li><strong>Bundle Size:</strong> Code-split database functionality to avoid large initial bundles</li>
                    <li><strong>Performance:</strong> Use virtual scrolling for large datasets</li>
                    <li><strong>Offline Support:</strong> Implement Service Workers for offline functionality</li>
                    <li><strong>Browser Compatibility:</strong> Ensure WASM support and fallbacks</li>
                    <li><strong>Memory Management:</strong> Implement proper cleanup for WebAssembly modules</li>
                    <li><strong>Security:</strong> Handle sensitive data in WASM securely</li>
                </ul>

                <div class="warning">
                    <strong>Critical Success Factors:</strong>
                    <ol>
                        <li>Preserve the event-driven architecture for maintainability</li>
                        <li>Maintain backend compatibility for collaboration features</li>
                        <li>Implement robust caching to match desktop performance</li>
                        <li>Ensure type safety throughout the application</li>
                        <li>Plan for offline-first functionality from the beginning</li>
                    </ol>
                </div>
            </section>
        </div>
    </main>

    <footer>
        <div class="container">
            <p>&copy; 2024 AppFlowy Database Architecture Documentation | Generated for Web Implementation Reference</p>
        </div>
    </footer>
</body>
</html>